//     Underscore.js 1.4.2
//     http://underscorejs.org
//     (c) 2009-2012 Jeremy Ashkenas, DocumentCloud Inc.
//     Underscore may be freely distributed under the MIT license.
(function () {
  const e = this; const t = e._; const n = {}; const r = Array.prototype; const i = Object.prototype; const s = Function.prototype; const o = r.push; const u = r.slice; const a = r.concat; const f = r.unshift; const l = i.toString; const c = i.hasOwnProperty; const h = r.forEach; const p = r.map; const d = r.reduce; const v = r.reduceRight; const m = r.filter; const g = r.every; const y = r.some; const b = r.indexOf; const w = r.lastIndexOf; const E = Array.isArray; const S = Object.keys; const x = s.bind; var T = function (e) { if (e instanceof T) return e; if (!(this instanceof T)) return new T(e); this._wrapped = e; }; typeof exports !== 'undefined' ? (typeof module !== 'undefined' && module.exports && (exports = module.exports = T), exports._ = T) : e._ = T, T.VERSION = '1.4.2'; const N = T.each = T.forEach = function (e, t, r) { if (e == null) return; if (h && e.forEach === h)e.forEach(t, r); else if (e.length === +e.length) { for (let i = 0, s = e.length; i < s; i++) if (t.call(r, e[i], i, e) === n) return; } else for (const o in e) if (T.has(e, o) && t.call(r, e[o], o, e) === n) return; }; T.map = T.collect = function (e, t, n) { const r = []; return e == null ? r : p && e.map === p ? e.map(t, n) : (N(e, (e, i, s) => { r[r.length] = t.call(n, e, i, s); }), r); }, T.reduce = T.foldl = T.inject = function (e, t, n, r) { let i = arguments.length > 2; e == null && (e = []); if (d && e.reduce === d) return r && (t = T.bind(t, r)), i ? e.reduce(t, n) : e.reduce(t); N(e, (e, s, o) => { i ? n = t.call(r, n, e, s, o) : (n = e, i = !0); }); if (!i) throw new TypeError('Reduce of empty array with no initial value'); return n; }, T.reduceRight = T.foldr = function (e, t, n, r) { let i = arguments.length > 2; e == null && (e = []); if (v && e.reduceRight === v) return r && (t = T.bind(t, r)), arguments.length > 2 ? e.reduceRight(t, n) : e.reduceRight(t); let s = e.length; if (s !== +s) { var o = T.keys(e); s = o.length; }N(e, (u, a, f) => { a = o ? o[--s] : --s, i ? n = t.call(r, n, e[a], a, f) : (n = e[a], i = !0); }); if (!i) throw new TypeError('Reduce of empty array with no initial value'); return n; }, T.find = T.detect = function (e, t, n) { let r; return C(e, (e, i, s) => { if (t.call(n, e, i, s)) return r = e, !0; }), r; }, T.filter = T.select = function (e, t, n) { const r = []; return e == null ? r : m && e.filter === m ? e.filter(t, n) : (N(e, (e, i, s) => { t.call(n, e, i, s) && (r[r.length] = e); }), r); }, T.reject = function (e, t, n) { const r = []; return e == null ? r : (N(e, (e, i, s) => { t.call(n, e, i, s) || (r[r.length] = e); }), r); }, T.every = T.all = function (e, t, r) { t || (t = T.identity); let i = !0; return e == null ? i : g && e.every === g ? e.every(t, r) : (N(e, (e, s, o) => { if (!(i = i && t.call(r, e, s, o))) return n; }), !!i); }; var C = T.some = T.any = function (e, t, r) { t || (t = T.identity); let i = !1; return e == null ? i : y && e.some === y ? e.some(t, r) : (N(e, (e, s, o) => { if (i || (i = t.call(r, e, s, o))) return n; }), !!i); }; T.contains = T.include = function (e, t) { let n = !1; return e == null ? n : b && e.indexOf === b ? e.indexOf(t) != -1 : (n = C(e, (e) => e === t), n); }, T.invoke = function (e, t) { const n = u.call(arguments, 2); return T.map(e, (e) => (T.isFunction(t) ? t : e[t]).apply(e, n)); }, T.pluck = function (e, t) { return T.map(e, (e) => e[t]); }, T.where = function (e, t) { return T.isEmpty(t) ? [] : T.filter(e, (e) => { for (const n in t) if (t[n] !== e[n]) return !1; return !0; }); }, T.max = function (e, t, n) { if (!t && T.isArray(e) && e[0] === +e[0] && e.length < 65535) return Math.max.apply(Math, e); if (!t && T.isEmpty(e)) return -Infinity; let r = { computed: -Infinity }; return N(e, (e, i, s) => { const o = t ? t.call(n, e, i, s) : e; o >= r.computed && (r = { value: e, computed: o }); }), r.value; }, T.min = function (e, t, n) { if (!t && T.isArray(e) && e[0] === +e[0] && e.length < 65535) return Math.min.apply(Math, e); if (!t && T.isEmpty(e)) return Infinity; let r = { computed: Infinity }; return N(e, (e, i, s) => { const o = t ? t.call(n, e, i, s) : e; o < r.computed && (r = { value: e, computed: o }); }), r.value; }, T.shuffle = function (e) { let t; let n = 0; const r = []; return N(e, (e) => { t = T.random(n++), r[n - 1] = r[t], r[t] = e; }), r; }; const k = function (e) { return T.isFunction(e) ? e : function (t) { return t[e]; }; }; T.sortBy = function (e, t, n) { const r = k(t); return T.pluck(T.map(e, (e, t, i) => ({ value: e, index: t, criteria: r.call(n, e, t, i) })).sort((e, t) => { const n = e.criteria; const r = t.criteria; if (n !== r) { if (n > r || n === void 0) return 1; if (n < r || r === void 0) return -1; } return e.index < t.index ? -1 : 1; }), 'value'); }; const L = function (e, t, n, r) { const i = {}; const s = k(t); return N(e, (t, o) => { const u = s.call(n, t, o, e); r(i, u, t); }), i; }; T.groupBy = function (e, t, n) { return L(e, t, n, (e, t, n) => { (T.has(e, t) ? e[t] : e[t] = []).push(n); }); }, T.countBy = function (e, t, n) { return L(e, t, n, (e, t, n) => { T.has(e, t) || (e[t] = 0), e[t]++; }); }, T.sortedIndex = function (e, t, n, r) { n = n == null ? T.identity : k(n); const i = n.call(r, t); let s = 0; let o = e.length; while (s < o) { const u = s + o >>> 1; n.call(r, e[u]) < i ? s = u + 1 : o = u; } return s; }, T.toArray = function (e) { return e ? e.length === +e.length ? u.call(e) : T.values(e) : []; }, T.size = function (e) { return e.length === +e.length ? e.length : T.keys(e).length; }, T.first = T.head = T.take = function (e, t, n) { return t != null && !n ? u.call(e, 0, t) : e[0]; }, T.initial = function (e, t, n) { return u.call(e, 0, e.length - (t == null || n ? 1 : t)); }, T.last = function (e, t, n) { return t != null && !n ? u.call(e, Math.max(e.length - t, 0)) : e[e.length - 1]; }, T.rest = T.tail = T.drop = function (e, t, n) { return u.call(e, t == null || n ? 1 : t); }, T.compact = function (e) { return T.filter(e, (e) => !!e); }; var A = function (e, t, n) { return N(e, (e) => { T.isArray(e) ? t ? o.apply(n, e) : A(e, t, n) : n.push(e); }), n; }; T.flatten = function (e, t) { return A(e, t, []); }, T.without = function (e) { return T.difference(e, u.call(arguments, 1)); }, T.uniq = T.unique = function (e, t, n, r) { const i = n ? T.map(e, n, r) : e; const s = []; const o = []; return N(i, (n, r) => { if (t ? !r || o[o.length - 1] !== n : !T.contains(o, n))o.push(n), s.push(e[r]); }), s; }, T.union = function () { return T.uniq(a.apply(r, arguments)); }, T.intersection = function (e) { const t = u.call(arguments, 1); return T.filter(T.uniq(e), (e) => T.every(t, (t) => T.indexOf(t, e) >= 0)); }, T.difference = function (e) { const t = a.apply(r, u.call(arguments, 1)); return T.filter(e, (e) => !T.contains(t, e)); }, T.zip = function () { const e = u.call(arguments); const t = T.max(T.pluck(e, 'length')); const n = new Array(t); for (let r = 0; r < t; r++)n[r] = T.pluck(e, `${r}`); return n; }, T.object = function (e, t) { const n = {}; for (let r = 0, i = e.length; r < i; r++)t ? n[e[r]] = t[r] : n[e[r][0]] = e[r][1]; return n; }, T.indexOf = function (e, t, n) { if (e == null) return -1; let r = 0; const i = e.length; if (n) { if (typeof n !== 'number') return r = T.sortedIndex(e, t), e[r] === t ? r : -1; r = n < 0 ? Math.max(0, i + n) : n; } if (b && e.indexOf === b) return e.indexOf(t, n); for (;r < i; r++) if (e[r] === t) return r; return -1; }, T.lastIndexOf = function (e, t, n) { if (e == null) return -1; const r = n != null; if (w && e.lastIndexOf === w) return r ? e.lastIndexOf(t, n) : e.lastIndexOf(t); let i = r ? n : e.length; while (i--) if (e[i] === t) return i; return -1; }, T.range = function (e, t, n) { arguments.length <= 1 && (t = e || 0, e = 0), n = arguments[2] || 1; const r = Math.max(Math.ceil((t - e) / n), 0); let i = 0; const s = new Array(r); while (i < r)s[i++] = e, e += n; return s; }; const O = function () {}; T.bind = function (t, n) {
    let r; let i; if (t.bind === x && x) return x.apply(t, u.call(arguments, 1)); if (!T.isFunction(t)) throw new TypeError(); return i = u.call(arguments, 2), r = function () {
      if (this instanceof r) {
        O.prototype = t.prototype; const e = new O(); const
          s = t.apply(e, i.concat(u.call(arguments))); return Object(s) === s ? s : e;
      } return t.apply(n, i.concat(u.call(arguments)));
    };
  }, T.bindAll = function (e) { let t = u.call(arguments, 1); return t.length == 0 && (t = T.functions(e)), N(t, (t) => { e[t] = T.bind(e[t], e); }), e; }, T.memoize = function (e, t) { const n = {}; return t || (t = T.identity), function () { const r = t.apply(this, arguments); return T.has(n, r) ? n[r] : n[r] = e.apply(this, arguments); }; }, T.delay = function (e, t) { const n = u.call(arguments, 2); return setTimeout(() => e.apply(null, n), t); }, T.defer = function (e) { return T.delay.apply(T, [e, 1].concat(u.call(arguments, 1))); }, T.throttle = function (e, t) { let n; let r; let i; let s; let o; let u; const a = T.debounce(() => { o = s = !1; }, t); return function () { n = this, r = arguments; const f = function () { i = null, o && (u = e.apply(n, r)), a(); }; return i || (i = setTimeout(f, t)), s ? o = !0 : (s = !0, u = e.apply(n, r)), a(), u; }; }, T.debounce = function (e, t, n) { let r; let i; return function () { const s = this; const o = arguments; const u = function () { r = null, n || (i = e.apply(s, o)); }; const a = n && !r; return clearTimeout(r), r = setTimeout(u, t), a && (i = e.apply(s, o)), i; }; }, T.once = function (e) { let t = !1; let n; return function () { return t ? n : (t = !0, n = e.apply(this, arguments), e = null, n); }; }, T.wrap = function (e, t) { return function () { const n = [e]; return o.apply(n, arguments), t.apply(this, n); }; }, T.compose = function () { const e = arguments; return function () { let t = arguments; for (let n = e.length - 1; n >= 0; n--)t = [e[n].apply(this, t)]; return t[0]; }; }, T.after = function (e, t) { return e <= 0 ? t() : function () { if (--e < 1) return t.apply(this, arguments); }; }, T.keys = S || function (e) { if (e !== Object(e)) throw new TypeError('Invalid object'); const t = []; for (const n in e)T.has(e, n) && (t[t.length] = n); return t; }, T.values = function (e) { const t = []; for (const n in e)T.has(e, n) && t.push(e[n]); return t; }, T.pairs = function (e) { const t = []; for (const n in e)T.has(e, n) && t.push([n, e[n]]); return t; }, T.invert = function (e) { const t = {}; for (const n in e)T.has(e, n) && (t[e[n]] = n); return t; }, T.functions = T.methods = function (e) { const t = []; for (const n in e)T.isFunction(e[n]) && t.push(n); return t.sort(); }, T.extend = function (e) { return N(u.call(arguments, 1), (t) => { for (const n in t)e[n] = t[n]; }), e; }, T.pick = function (e) { const t = {}; const n = a.apply(r, u.call(arguments, 1)); return N(n, (n) => { n in e && (t[n] = e[n]); }), t; }, T.omit = function (e) { const t = {}; const n = a.apply(r, u.call(arguments, 1)); for (const i in e)T.contains(n, i) || (t[i] = e[i]); return t; }, T.defaults = function (e) { return N(u.call(arguments, 1), (t) => { for (const n in t)e[n] == null && (e[n] = t[n]); }), e; }, T.clone = function (e) { return T.isObject(e) ? T.isArray(e) ? e.slice() : T.extend({}, e) : e; }, T.tap = function (e, t) { return t(e), e; }; var M = function (e, t, n, r) { if (e === t) return e !== 0 || 1 / e == 1 / t; if (e == null || t == null) return e === t; e instanceof T && (e = e._wrapped), t instanceof T && (t = t._wrapped); const i = l.call(e); if (i != l.call(t)) return !1; switch (i) { case '[object String]': return e == String(t); case '[object Number]': return e != +e ? t != +t : e == 0 ? 1 / e == 1 / t : e == +t; case '[object Date]': case '[object Boolean]': return +e == +t; case '[object RegExp]': return e.source == t.source && e.global == t.global && e.multiline == t.multiline && e.ignoreCase == t.ignoreCase; } if (typeof e !== 'object' || typeof t !== 'object') return !1; let s = n.length; while (s--) if (n[s] == e) return r[s] == t; n.push(e), r.push(t); let o = 0; let u = !0; if (i == '[object Array]') { o = e.length, u = o == t.length; if (u) while (o--) if (!(u = M(e[o], t[o], n, r))) break; } else { const a = e.constructor; const f = t.constructor; if (a !== f && !(T.isFunction(a) && a instanceof a && T.isFunction(f) && f instanceof f)) return !1; for (var c in e) if (T.has(e, c)) { o++; if (!(u = T.has(t, c) && M(e[c], t[c], n, r))) break; } if (u) { for (c in t) if (T.has(t, c) && !(o--)) break; u = !o; } } return n.pop(), r.pop(), u; }; T.isEqual = function (e, t) { return M(e, t, [], []); }, T.isEmpty = function (e) { if (e == null) return !0; if (T.isArray(e) || T.isString(e)) return e.length === 0; for (const t in e) if (T.has(e, t)) return !1; return !0; }, T.isElement = function (e) { return !!e && e.nodeType === 1; }, T.isArray = E || function (e) { return l.call(e) == '[object Array]'; }, T.isObject = function (e) { return e === Object(e); }, N(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], (e) => { T[`is${e}`] = function (t) { return l.call(t) == `[object ${e}]`; }; }), T.isArguments(arguments) || (T.isArguments = function (e) { return !!e && !!T.has(e, 'callee'); }), typeof /./ !== 'function' && (T.isFunction = function (e) { return typeof e === 'function'; }), T.isFinite = function (e) { return T.isNumber(e) && isFinite(e); }, T.isNaN = function (e) { return T.isNumber(e) && e != +e; }, T.isBoolean = function (e) { return e === !0 || e === !1 || l.call(e) == '[object Boolean]'; }, T.isNull = function (e) { return e === null; }, T.isUndefined = function (e) { return e === void 0; }, T.has = function (e, t) { return c.call(e, t); }, T.noConflict = function () { return e._ = t, this; }, T.identity = function (e) { return e; }, T.times = function (e, t, n) { for (let r = 0; r < e; r++)t.call(n, r); }, T.random = function (e, t) { return t == null && (t = e, e = 0), e + (0 | Math.random() * (t - e + 1)); }; const _ = {
    escape: {
      '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#x27;', '/': '&#x2F;',
    },
  }; _.unescape = T.invert(_.escape); const D = { escape: new RegExp(`[${T.keys(_.escape).join('')}]`, 'g'), unescape: new RegExp(`(${T.keys(_.unescape).join('|')})`, 'g') }; T.each(['escape', 'unescape'], (e) => { T[e] = function (t) { return t == null ? '' : (`${t}`).replace(D[e], (t) => _[e][t]); }; }), T.result = function (e, t) { if (e == null) return null; const n = e[t]; return T.isFunction(n) ? n.call(e) : n; }, T.mixin = function (e) { N(T.functions(e), (t) => { const n = T[t] = e[t]; T.prototype[t] = function () { const e = [this._wrapped]; return o.apply(e, arguments), F.call(this, n.apply(T, e)); }; }); }; let P = 0; T.uniqueId = function (e) { const t = P++; return e ? e + t : t; }, T.templateSettings = { evaluate: /<%([\s\S]+?)%>/g, interpolate: /<%=([\s\S]+?)%>/g, escape: /<%-([\s\S]+?)%>/g }; const H = /(.)^/; const B = {
    "'": "'", '\\': '\\', '\r': 'r', '\n': 'n', '	': 't', '\u2028': 'u2028', '\u2029': 'u2029',
  }; const j = /\\|'|\r|\n|\t|\u2028|\u2029/g; T.template = function (e, t, n) { n = T.defaults({}, n, T.templateSettings); const r = new RegExp(`${[(n.escape || H).source, (n.interpolate || H).source, (n.evaluate || H).source].join('|')}|$`, 'g'); let i = 0; let s = "__p+='"; e.replace(r, (t, n, r, o, u) => { s += e.slice(i, u).replace(j, (e) => `\\${B[e]}`), s += n ? `'+\n((__t=(${n}))==null?'':_.escape(__t))+\n'` : r ? `'+\n((__t=(${r}))==null?'':__t)+\n'` : o ? `';\n${o}\n__p+='` : '', i = u + t.length; }), s += "';\n", n.variable || (s = `with(obj||{}){\n${s}}\n`), s = `var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};\n${s}return __p;\n`; try { var o = new Function(n.variable || 'obj', '_', s); } catch (u) { throw u.source = s, u; } if (t) return o(t, T); const a = function (e) { return o.call(this, e, T); }; return a.source = `function(${n.variable || 'obj'}){\n${s}}`, a; }, T.chain = function (e) { return T(e).chain(); }; var F = function (e) { return this._chain ? T(e).chain() : e; }; T.mixin(T), N(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], (e) => { const t = r[e]; T.prototype[e] = function () { const n = this._wrapped; return t.apply(n, arguments), (e == 'shift' || e == 'splice') && n.length === 0 && delete n[0], F.call(this, n); }; }), N(['concat', 'join', 'slice'], (e) => { const t = r[e]; T.prototype[e] = function () { return F.call(this, t.apply(this._wrapped, arguments)); }; }), T.extend(T.prototype, { chain() { return this._chain = !0, this; }, value() { return this._wrapped; } });
}).call(this);
